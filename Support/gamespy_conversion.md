Plan: Replacing GameSpy API in C&C: Generals – Zero Hour with a Modular WinSock Networking System
Overview of GameSpy API Calls in Zero Hour
GameSpy Services Used: Generals – Zero Hour relies on GameSpy’s middleware for online features including user login/authentication, game matchmaking (finding/hosting games), chat lobby communication, NAT traversal, and stats/ranking​
CNC.FANDOM.COM
​
CNC.FANDOM.COM
. Under the hood, the game connects to several GameSpy endpoints: for example, gpcm.gamespy.com (GameSpy login service), peerchat.gamespy.com (chat/lobby server), a game-specific master server (e.g. ccgenzh.ms6.gamespy.com) for listing available games, and gamestats.gamespy.com for stats​
REDDIT.COM
. Each of these corresponds to a GameSpy API call or function in the original game code (such as login, fetching the server list, etc.).Key GameSpy Functions: In Zero Hour’s original code (using GameSpy’s SDK), the game would initialize the GameSpy backend and perform calls roughly as follows (in pseudo-terms):
Initialization: e.g. GameSpy_Initialize(...) – sets up GameSpy SDK with game identifiers (product ID, keys, etc.).
Login/Authentication: e.g. GameSpy_Login(username, password, ...) – contacts GameSpy’s login server (at gpcm.gamespy.com:29900​
GAMEFAQS.GAMESPOT.COM
) to authenticate the user’s GameSpy ID.
Lobby/Chat Connection: e.g. GameSpy_ConnectChat(...) – connects to the chat/lobby server (at peerchat.gamespy.com:6667​
GAMEFAQS.GAMESPOT.COM
, an IRC-like service) to join chat rooms (game lobbies) and show online players.
Server/Matchmaking Listing: e.g. GameSpy_QueryGames(...) – queries the master server (e.g. ccgenzh.ms6.gamespy.com on default port 28900​
FORUMS.CIVFANATICS.COM
) for the list of available game sessions. Hosts periodically send heartbeats to this master server to announce or update their games​
POKEACER.XYZ
. Clients retrieve the list and may send ping queries to each host for details like latency​
POKEACER.XYZ
.
NAT Negotiation: If a host or player is behind a NAT, the game uses GameSpy’s NAT Negotiation API to facilitate peer-to-peer connection. This typically involves a NATNeg server (e.g. natnegX.gamespy.com) acting as a handshake mediator​
POKEACER.XYZ
. The original game would call something like GameSpy_StartNatNegotiation(cookie, hostIP, ...) to coordinate punching through NAT firewalls.
Game Hosting/Joining: e.g. GameSpy_CreateGame(roomInfo) and GameSpy_JoinGame(roomID) – in the lobby, the host creates a game (staging room) which others can join. The GameSpy Peer SDK (if used) wraps the listing and NAT logic, making games visible in the lobby and handling invites. Internally this would use the above services (reporting to master server, joining chat channels for the game, etc.).
Stats and Others: e.g. GameSpy_ReportStats(gameResult) – sends end-of-game stats to gamestats.gamespy.com (not critical for basic connectivity).
Summary: The core GameSpy calls revolve around: user authentication, retrieving/refreshing the game list, joining/creating chat lobbies and game rooms, exchanging game invites, and maintaining connections through NAT. Our plan will replace each of these with new implementations using WinSock and custom logic, while preserving the game’s expected behavior.
Intercepting and Replacing GameSpy Calls
To integrate our new networking system without modifying the game’s core logic, we intercept calls that Zero Hour makes to the GameSpy API and redirect them to our own implementations. There are two primary strategies to achieve this:
DLL Hook/Replacement: If the game dynamically links to GameSpy libraries, we can create a proxy DLL that exposes the same function names GameSpy did, but implements them with our new code. For example, if the game calls gpLogin() from GameSpy.dll, our replacement GameSpy.dll will intercept that call and execute Our_LoginFunction() instead of the real one. This way, Zero Hour calls our code seamlessly.
Function Detouring: If GameSpy code is statically compiled into the game, we will use hooking (e.g. Microsoft Detours or a similar technique) to detour the function calls at runtime. We identify the memory addresses of key GameSpy functions (like the login and listing routines) in the binary and overwrite their entry instructions with a jump to our replacement routines. When the game invokes those functions, it will jump into our code. We ensure the original function’s signature is preserved so that the game’s expectations (return values, callbacks, etc.) remain consistent.
Hook Setup: During game launch (via an injected DLL or launcher), initialize the hooks before the game attempts any online connectivity. For instance, hook the GameSpy initialization call so it calls InitBackend() (our function) instead. Similarly, hook the login call to our Backend_Login() implementation, the game listing refresh call to our Backend_FetchGameList(), and so on. This granular hooking allows us to replace the GameSpy components one by one:
Authentication: Hook the function responsible for sending credentials so it calls our Revora authentication logic.
Lobby Connect: Hook any function that joins chat or lobby so it uses our chat backend (or a dummy if we handle lobby listing differently).
Game List Queries: Hook the refresh function for server lists to call our routine that queries the new master server.
NAT Negotiation: Hook the GameSpy NAT negotiation initiation call to our own NAT punch-through handler.
Game Invites: Hook any GameSpy invite or buddy messaging function to our invite implementation.
By intercepting at the API level, we minimize changes to game UI or flow – the game “thinks” it’s still calling GameSpy, but underneath we provide the responses via WinSock connections to the new backend. We will maintain any callback mechanism the original had: for example, if GameSpy_Login was asynchronous and invoked a callback on success, our replacement will similarly spawn a thread or non-blocking call, then invoke the game’s callback function with the appropriate parameters once done. All original data structures passed to/from these functions (e.g. game list structures, player info) will be populated with our data so that the rest of the game code can use them as normal.
Implementation Steps
Below is a step-by-step breakdown for implementing the new networking system using WinSock, covering each major feature. We use Revora’s C&C:Online as the default backend in these steps, but design it to be configurable for others like OpenSpy.
1. Initialization and Configuration
Before any network operation, set up our modular backend system:
WinSock Startup: Initialize WinSock (e.g. call WSAStartup for Windows sockets) early in the game’s startup (either in our injected DLL DllMain or at the hook of GameSpy’s init function). This ensures we can create sockets for TCP/UDP as needed.
Load Config & Select Backend: Read a configuration file or setting that specifies which backend to use (e.g. Revora by default, or OpenSpy alternative). This config will contain the server addresses and ports for each service (login, lobby, etc.). For Revora, default to their known endpoints (which often reuse GameSpy’s protocols). For example, Revora’s C&C:Online may use cnc-online.net servers or simply expect the GameSpy hostnames to be redirected. For OpenSpy, use their server IP (as in the host file overrides​
REDDIT.COM
). Store this info in a BackendConfig structure (see Function Signatures & Data Structures below).
Backend Interface: Based on the selected backend, instantiate the appropriate backend handler. For Revora, we might use a RevoraBackend module that knows Revora’s specifics. This module will handle subsequent authentication, listing, etc., using our WinSock implementation.
By performing this initialization, we prepare the ground for all subsequent steps and ensure the backend addresses/ports are configured. We also open any persistent connections if needed (for example, some backends may maintain a persistent socket for chat or keep-alive messages).
2. Handling Authentication with Revora’s Servers
User login is the first critical step. We replace the GameSpy login sequence with one that authenticates against Revora (C&C:Online):
Capture Credentials: When the game calls the login function (e.g. user enters their nickname/email and password in-game), our hook intercepts it. We retrieve the username and password parameters from the call. (If the game supports creating new accounts, we would similarly intercept that and call an appropriate registration API or stub, but primarily focus on login).
Connect to Login Server: Using WinSock, open a TCP connection to the configured login server. For Revora, this is functionally a GameSpy login emulator – typically at gpcm.gamespy.com on port 29900​
GAMEFAQS.GAMESPOT.COM
 (Revora often uses the same address via hosts override, or provides an equivalent address). Our BackendConfig will have the correct host (which may still be “gpcm.gamespy.com” if a hosts file or DNS is redirecting it to Revora’s IP, or a direct Revora domain/IP). Use gethostbyname/connect with the address and port 29900.
Authentication Protocol: Formulate the login request according to the GameSpy GP (GameSpy Presence) protocol, which Revora’s server expects. This involves sending the user credentials and game info. The protocol typically starts with a challenge exchange – for example, the server might send a challenge string upon connection, and the client must hash the password with this challenge. Implement the required hashing (GameSpy often uses an MD5 of the password and challenge). Then send the login packet (for GameSpy, a formatted string with tags, e.g. \login\username\USER\password\HASH...). Ensure to include any required fields (GameSpy login required a “product ID” and “namespace” which identify the game – these values should match Zero Hour’s original GameSpy ID so that Revora knows which game is logging in).
Handle Response: Wait for the server’s response over the TCP socket. Using recv(), read the data and parse it. A successful login typically returns a confirmation and a session ID or profile ID. Parse out the success code and any user ID or session cookie from Revora. If the server indicates failure (bad credentials), capture the error message or code.
Complete Login Handshake: If additional steps are required (GameSpy GP might require acknowledging terms or retrieving buddy list at login), perform those by sending/receiving as needed. For example, after initial auth, the client might send a \list\ request to get buddies or a \login\final\ acknowledgment. Implement those sub-calls according to the protocol documentation (this information can be gleaned from open-source GameSpy login server projects).
Notify Game of Result: Once authentication is successful, call the original game’s callback or set the appropriate state to indicate “login succeeded.” For instance, if the original GameSpy SDK would trigger a callback LoginSuccess(playerID), we invoke that with the data we parsed (making the game think “GameSpy” logged in normally). If login failed, similarly call the failure callback or set an error flag so the game can display “Invalid login” to the user. Our implementation should also store the authenticated session details (like a session token or profile ID) in a global structure, as it will be needed for further interactions (e.g. to authenticate with other services like chat or game listing).
By completing these steps, the user is now authenticated with Revora’s server. In practice, Revora requires players to register an account on their site – the username/password entered in-game should correspond to that account. Our system simply passes those credentials to Revora’s login server using the same method the original GameSpy service would, so from the user’s perspective, logging in works as it did before (just now through our code).Debug tip: Enable verbose logging for this step (at least during development). Log the raw messages sent to and received from the login server (except sensitive info like passwords) to a file (e.g. logs\login.log). This helps verify that the handshake is proceeding correctly (e.g. correct challenge response, etc.) if the login fails.
3. Retrieving and Displaying the Game Lobby List
Once logged in, the player will typically choose a lobby or see the list of available games to join. We implement the listing of game sessions (matchmaking lobby) by communicating with the new backend’s master server or lobby service:
Join a Lobby or Request List: In Zero Hour, after login, players enter an online lobby (which might be a chat room like “Lobby 1”). Under GameSpy, this could involve joining a chat channel via peerchat. We have two possible approaches:
Approach A: Use the chat server to get game list updates (e.g. monitor a “room” where hosts announce games).
Approach B (Direct Query): Query the master server for the list of games.
For simplicity and reliability, we use direct querying of the master server (Revora runs a master server that mimics GameSpy’s). We hook the function that the game calls to refresh the game list (e.g. when you open the “Custom Match” lobby screen or hit a refresh button). Our implementation then issues a request for the game session list to the backend. If the game originally used GameSpy’s Server Browser (SB) API, it might send a query packet to ccgenzh.ms6.gamespy.com or master.gamespy.com on port 28900​
FORUMS.CIVFANATICS.COM
. We will do the equivalent: use WinSock to send a UDP or TCP query (depending on protocol; GameSpy master server queries are often UDP) to Revora’s master server. The query typically includes the game’s identifier and possibly filters (e.g. “list all active games for Zero Hour”).
Master Server Response: Receive the list of games from the master server. The response might come as a series of packets containing each game’s info (host IP, port, current players, max players, game name, etc.). Parse these into a structured list. For GameSpy’s QR2/Server Browser, the master server often returns a list of addresses first, and then the client pings each address for detailed info​
POKEACER.XYZ
. If Revora’s system is similar, we may get a list of game server IPs. In that case, iterate through them and send a small UDP query (e.g. “getinfo” query) to each host’s game port to retrieve detailed info (the game host, via our code or the engine’s built-in responder, will reply with its server name, map, etc.). Collect these responses. (If NAT traversal is required, these pings might already be going through a NAT negotiation step — see next section — but for listing, usually it’s just basic info or the master already filtered unreachable servers).
Populate Lobby UI Data: Take the compiled list of games and populate the game’s internal data structures that represent the lobby list. For example, fill an array of GameSession objects with fields like Game Name, Host name, player count, ping (if measured), etc. Then call the original function that updates the UI or triggers the display refresh. In many cases, the GameSpy SDK would have invoked a callback like “ServerListCallback(gameList)”. We simulate this by calling that callback or by directly feeding the data into the UI variables if the game expects the data synchronously. The result is that the in-game server browser now shows the active games retrieved from Revora’s backend.
Continuous Update: Lobbies often update periodically. We ensure that our code can refresh the list on demand. Possibly spawn a background thread or use the game’s existing ticking mechanism (the game might call a GameSpy “think” function each frame or every few seconds). At each tick, process incoming packets (e.g. if new game list data arrives or a new host heartbeat is detected). If the game allows real-time lobby updates (auto-refresh), handle adding or removing game entries accordingly. Otherwise, on user hitting “refresh”, simply redo steps 1–3.
Creating a Game (Hosting): When the user hosts a new game, intercept that action to register the game on the master server. This involves sending a “start hosting” message to Revora. GameSpy’s original flow would send a heartbeat to the master server with game parameters​
POKEACER.XYZ
, and continuously update it. Our implementation should open a UDP socket for the host and send a registration packet: include info like the host’s public IP (if known, or let the master deduce it), the chosen game name, and a unique session ID or “cookie”. Also, notify the NAT server (if behind NAT) that this host will accept connections (more on NAT below). On success, the master server will list this game for others to see. We then allow the game UI to proceed to the staging room (where the host waits for players). Our code will maintain a heartbeat: e.g. every 20 seconds, send an update to master so it knows the game is still active​
POKEACER.XYZ
. On game termination, send a removal signal to the master so it stops listing it.
By implementing the above, players can see the multiplayer game lobby just as they did with GameSpy, but backed by Revora. The use of direct master server querying ensures the game list is obtained reliably. If instead we had opted for the chat-based approach, we would connect to peerchat.gamespy.com (or Revora’s equivalent) via IRC and join a channel (like ZeroHourLobby1), then parse chat messages for game announcements. This is more complex and not necessary given the master server approach, but our system is flexible enough that we could integrate chat if needed (for example, to enable the global chat in the lobby interface).Debug tip: Log the number of games and key details each time a refresh occurs (e.g. “Received 5 games from master server, including Game1 (host IP X)…”) to a lobby.log. This helps ensure the parsing is correct. Also, during testing, one can simulate a host by running a local dummy server that replies to queries to validate the listing logic without a second player.
4. NAT Punch-Through for Peer-to-Peer Connections
NAT traversal is crucial for players behind routers. Our system will implement NAT punch-through akin to GameSpy’s NAT Negotiation (NatNeg) service to allow peers to connect directly​
POKEACER.XYZ
:
Determine NAT Status: When a player hosts a game or attempts to join one, check if they are behind NAT. This can be done by comparing the local IP with the external IP we see (for example, when contacting the master server, the master can report back the perceived external address, or use a STUN-like approach with a small query to a known echo server). Mark each peer as NAT or non-NAT.
Initiate NAT Negotiation (Host): If a host is behind NAT, we will use a NAT negotiation server. Revora likely runs a NATNeg server (since GameSpy’s tech was fully cloned​
CNC.FANDOM.COM
). Using WinSock (UDP), contact the NATNeg server (e.g. natneg1.cnc-online.net or if Revora simply reuses GameSpy addresses, something like natneg1.gamespy.com via hosts file). The host sends a message indicating willingness to negotiate NAT and includes a unique session cookie (this could be a random number or one assigned by the master server for this match). The message typically contains: “I am host of game X, here is my cookie, my internal port Y”. The NATNeg server will record the host’s external IP:port from this UDP packet.
Initiate NAT Negotiation (Client): When a client decides to join a game (after selecting from the list or accepting an invite), if either client or host is NAT’d (usually at least one will be, in home setups), begin NAT negotiation. The client also sends a UDP packet to the NATNeg server with the same cookie indicating “I want to join game X, here is my info”. Now the NATNeg server has both the host and client external addresses and the shared cookie identifying the session.
Coordinate Hole-Punch: The NATNeg server now informs both parties to start punching through. In GameSpy’s protocol, the server might either respond to each with the other’s external address, or simply forward one party’s UDP to the other’s address (to prime the connection). In our implementation, we can have the NATNeg server respond to both host and client with a message: “begin connect to [peer_external_ip]:[peer_port] now”. Our code, upon receiving that, will immediately attempt to send UDP packets directly to the other peer’s address and port (this is the hole-punch attempt). Both sides do this simultaneously. Because each side’s NAT router sees an outgoing packet to the other, it will (in many NAT types) allow the corresponding incoming packet from the other side. This hopefully establishes peer-to-peer communication.
Finalize Connection: If the punch-through is successful, the host and client can now communicate directly (the game’s own peer networking protocol will take over on this connection). Our hooking layer should detect that the direct connection is established. For example, the game might call GameSpy_NatNegComplete() or simply attempt the game data handshake (Zero Hour’s engine likely will attempt to connect to the host’s IP on a port once we supply that info). We ensure the engine is given the correct IP and port for the host. If our NAT negotiation succeeded, that IP will be the host’s external IP and the port that was opened (the host’s game port, which might be predetermined like 16000 or obtained from the host’s heartbeat info). We then allow the game to proceed with its normal connection process (which could involve exchanging encryption keys or sync checks between host and client – that happens at the game protocol level beyond our replacement scope).
Fallbacks and Port Forwarding: Not all NAT situations can be punched through (symmetric NATs often fail). We implement a timeout (e.g. if no direct connection is established within a few seconds of trying). If it fails, our system should inform the user or the UI (perhaps via the callback that originally would say “connection timed out”). We can also attempt a fallback: for instance, if Revora supports a relay server (not likely due to performance, but OpenSpy sometimes can act as a relay), or simply advise the user to set up port forwarding. In testing, we’d note which routers fail and ensure to document that UDP port (e.g. default game port, or the range 16000-~) should be forwarded as a last resort​
REALMSBEYOND.NET
.
By integrating NAT punch-through, we replicate GameSpy’s ability to connect players in peer-to-peer games despite routers​
POKEACER.XYZ
. The key is coordinating through a known third-party server – in our case, Revora’s (or OpenSpy’s) NATNeg service or a custom one we provide. Our implementation will be modular: the NAT negotiation server address can be in the config (Revora’s by default, but one could run their own for LAN or alternate service). If needed, we can implement a minimal NATNeg server ourselves (for example, as part of testing we could create a local UDP listener that mimics the behavior).Debug tip: Use logging and perhaps on-screen debug messages for NAT negotiation steps. For instance, log “NATNeg: Host [internal:port]->[external:port]” and “NATNeg: Client external received, attempting punch” etc. Also, we can enable a verbose mode where the game will show “Attempting NAT punch-through…” in the chat or a console, to make it clear what’s happening. Monitoring network traffic with a tool (like Wireshark) during testing is very helpful to see if the UDP packets are reaching each side.
5. Implementing Game Invitations and Joining a Hosted Match
Game invitations (inviting friends to your hosted game) and the process of joining are handled through the backend’s messaging system and our new network logic:
Buddy List & Presence: Zero Hour’s GameSpy integration includes a buddy list (friends) and presence information. When our login completes, we should also retrieve the user’s buddy list (if the game UI supports showing friends online). This can be done by a command to Revora’s login server or a separate profile service (GameSpy had gpsp.gamespy.com:29901 for such queries​
GAMEFAQS.GAMESPOT.COM
). Our plan is to initially focus on invites for players already in the same lobby rather than a full friends system, but we keep the hooks ready for buddy features. For completeness: implement a Backend_GetBuddyList() that queries and then indicate in the UI which friends are online (Revora may expose this via their APIs).
Sending Invites: If a player is in a game lobby (staging room) and chooses to invite a friend (from their buddy list or chat), intercept that action. Through the backend, send an invite message to the target player. With GameSpy, this would be done via their messaging service or chat whisper. In our system, we have two options:
Via Chat Server: If both players are connected to the chat server (peerchat), we can send a private message in a format that the client can interpret as an invite (GameSpy’s SDK likely had a structured invite message). For example, a message like “PlayerX invites you to join game #12345”. We could use a reserved command or just rely on Revora’s server to handle it if it has invite support.
Via Direct Notification: Use the profile service or a direct TCP message. Since the players are all connected to Revora’s backend (either via the persistent login socket or an event socket), we could have our backend send a notification packet to the invited client. Revora’s clone might support a “invite” command already. If not, we can simulate by sending a custom formatted message through the login connection (GP protocol had messaging commands for friends).
Invite Reception: The invited player’s client (through our hooked code) will receive the invite notification. We will intercept that either via the chat message hook or a special packet on the login connection. Once detected, we invoke the game’s invite-received routine, which usually pops up “PlayerX has invited you to join their game. Accept?” in the UI. All the data needed – the inviting player and a reference to the game session – should be included. (In our implementation, the “reference” could simply be the game’s ID or host name, which we ensure we have in our game list data or can fetch from the master server on the fly).
Join via Invite: If the user accepts the invite, the game will essentially attempt to join that specific session. We handle this like a normal join: find the game session (if we have an ID, use it to get host IP/port info if not already known), perform NAT negotiation if needed, and then connect. The difference is we bypass the need for the player to manually select the game from the list – we jump straight into the join procedure for that game. We must also possibly communicate to the host that the player accepted (though typically, the host’s game will find out when the player actually connects at the network level). If GameSpy had a pre-notification to host (“Your friend is joining”), we could mimic that via a chat message to host, but it’s not strictly necessary. The host’s game will see the new player when they connect.
Joining a Game (General): Whether via invite or by double-clicking a game in the list, the join process is the same after initiating: Our code will instruct the game engine to connect to the host. The engine might call something like GameSpy_JoinGame(hostIP, port) originally, or the Peer SDK would handle it. In our replacement, after we have the host’s external IP (post NAT-negotiation), we use WinSock to establish the connection. This could be a TCP connection for synchronization or a series of UDP exchanges – it depends on how the SAGE engine does networking. Many RTS games use peer-to-peer UDP for game data. Given that, we likely just need to inform the engine of the target address and let it do the rest (the engine might already create a socket and start sending game join packets). If needed, we can assist by creating a socket and binding it to the engine’s expected port, then handing it off or proxying data. However, since we intercept at a higher level, ideally we just feed the engine the correct info: e.g., patch the parameters of the join function call to use the resolved IP/port. The engine will then proceed to load the game, do player syncing, etc., over the now-established direct connection.
In-Game Session Management: Once players are connected in a game, our involvement is minimal – the game’s own networking code runs the show (exchanging moves, etc.). We do, however, maintain any necessary background tasks: e.g., continue to send heartbeats to master server (so the game remains listed until it’s full or started), possibly update the chat presence (mark players as “in game” so they don’t appear in the lobby), and keep an ear on the network in case someone drops (so we can update the master server if a game is aborted).
By implementing invites and joining logic, we ensure that all common multiplayer flows are covered. Friends can directly join each other, and random players can join via the lobby list – all going through our unified system.Debug tip: Test the invite flow thoroughly with two clients. Ensure that an invite from client A to B shows up on B, and that acceptance leads B into A’s game. Log each step (invite sent, invite received, join initiated) to invite.log. If an invite fails to deliver, verify that both clients were online and connected to the backend’s messaging – this could indicate an issue with how we’re sending the invite through the server.
6. Logging and Debugging Mechanisms
Throughout the implementation, robust logging and debugging tools are vital for smooth operation and maintenance:
Centralized Logging: Implement a logging module that all parts of the networking system use. For example, a NetLog class with methods like Info, Warn, Error that write to a log file (or stdout in a debug console). Each major component (auth, lobby, NAT, invites) should log key events. Use separate log files for each area or tag entries with a component label. For instance, when a login attempt starts, log “[AUTH] Connecting to login server…”, and on success “[AUTH] Login successful for user X (PID 12345)”. This makes it easier to trace the sequence after a test run.
In-Game Debug UI (Optional): During development or in a special build, it can be useful to display debug text in-game (since hooking a DLL allows drawing on screen or using the console if the game has one). This could be as simple as writing to the game’s chat window (if accessible) or rendering an overlay (GenTool does something similar by hooking DirectX). For example, on pressing a hotkey, toggle showing network debug info like current backend, ping to server, etc.
Error Handling & Reporting: All network calls should have error checking. If a socket fails to connect or times out, catch that and log it. Where possible, also surface it to the user in a friendly way. For instance, if login fails due to server unreachable, intercept the error and perhaps display “Unable to contact server – check your internet or server status” in the game’s UI (this might be done by tricking the game into thinking GameSpy returned a specific failure code which it then displays). Likewise for NAT failure – after a timeout, we could prompt “Unable to join – you may need to open port XYZ or try again.” These messages aid debugging for end-users and testers.
Session Logging: Maintain a high-level summary log for each play session. This could include timestamps for: login, lobby refreshes, game hosted/joined, NAT negotiation steps, and disconnects. This summary (maybe session.log) provides a narrative of what happened, useful for debugging logic issues or reporting to backend devs (e.g., if Revora’s server gave an unexpected response, we’d see it in context).
Debug Builds & Assertions: In a debug mode, include assertions or sanity checks. For example, after parsing the game list from the master server, assert that the number of entries matches what was indicated, or that each entry has a valid IP/port. If something is off, log an error with details to investigate.
Testing Tools: Develop small test routines callable via a console command or keystroke that perform specific checks. For instance, a “ping backend” test that simply tries to connect to each configured server (login, master, NAT) and reports success/latency. This can help quickly identify if any particular service is down or misconfigured, without going through the whole game flow.
By embedding these logging and debugging supports, we ensure that as we replace GameSpy’s functionality, any issues can be traced and resolved. This is particularly important given we don’t have source-level debug of the original game code; our logs are our insight into what’s happening. Before final release of the patch, we might disable or reduce logging (to avoid disk I/O overhead), but it’s wise to leave an option (like a config flag) for advanced users to enable logs if they encounter problems.
Function Signatures & Data Structures
Designing clear interfaces for our networking module will make the system maintainable and extensible. Below are key functions (with example signatures) and data structures for the new networking system:
cpp
Copy
// Configuration for backend servers
struct BackendConfig {
    std::string name;               // e.g. "Revora" or "OpenSpy"
    std::string loginServerHost;    // e.g. "gpcm.gamespy.com" (to be redirected via hosts or actual domain)
    uint16_t    loginServerPort;    // e.g. 29900
    std::string chatServerHost;     // e.g. "peerchat.gamespy.com"
    uint16_t    chatServerPort;     // e.g. 6667
    std::string masterServerHost;   // e.g. "ccgenzh.ms6.gamespy.com"
    uint16_t    masterServerPort;   // e.g. 28900
    std::string natNegServerHost;   // e.g. "natneg1.gamespy.com"
    uint16_t    natNegServerPort;   // e.g. 27901 (example port for NAT server)
    // ... any other endpoints like stats server if needed.
};

// Representation of a game session (lobby game listing)
struct GameSessionInfo {
    uint32_t    sessionID;       // Unique ID for the session (could be assigned by master or derived)
    std::string hostName;        // Host player’s name
    std::string hostIP;          // Host IP (external) as string
    uint16_t    hostPort;        // Host game port
    std::string sessionName;     // Name of the game (room name)
    uint8_t     curPlayers;      // Current number of players
    uint8_t     maxPlayers;      // Maximum players allowed
    bool        requiresPassword; // Whether the game is password-protected
    // Additional info: map name, etc., could be included as needed
};

// Representation of a player (for authentication and invites)
struct PlayerInfo {
    std::string username;
    uint32_t    profileID;      // Unique player ID from backend (if provided by login)
    bool        online;
    // Perhaps other fields like rank, but for core networking, this is enough.
};

// Abstract interface for backend interactions
class GameBackend {
public:
    virtual bool Initialize(const BackendConfig& config) = 0;
    virtual bool Login(const std::string& username, const std::string& password) = 0;
    virtual void Logout() = 0;
    virtual bool FetchGameList(std::vector<GameSessionInfo>& outList) = 0;
    virtual bool HostGame(const GameSessionInfo& gameInfo) = 0;
    virtual bool CancelHost() = 0;
    virtual bool JoinGame(const GameSessionInfo& gameInfo) = 0;
    virtual bool SendInvite(const std::string& targetUser, uint32_t sessionID) = 0;
    virtual void PumpEvents() = 0; // Process incoming data (to be called periodically)
    virtual ~GameBackend() {}
};
BackendConfig: holds all the network endpoints and possibly credentials (like a game-specific secret key if needed for authentication protocols). This is populated from a config file or defaults and passed to the backend during initialization. It allows easy switching of servers. For example, to use OpenSpy, one would set loginServerHost to OpenSpy’s IP or domain (OpenSpy often uses the same hostnames but one could directly use their domain or IP)​
REDDIT.COM
.
GameSessionInfo: a structure to encapsulate the information about each game session in the lobby. This is used when populating the list and when attempting to join a specific game. It contains both the networking info (IP/port) and user-friendly info (names, player counts). This structure is filled by FetchGameList and used by JoinGame.
PlayerInfo: could be used for tracking the local player and friends. profileID might be issued by the backend on login (GameSpy uses numerical profile IDs). We could store the local player’s info globally for reference. For invites, we might also keep a map of friend username -> profileID or connection details to send targeted messages.
GameBackend interface: defines the operations our networking system must support. We can implement this interface for each backend:
Initialize – set up any persistent connections or data. For example, for Revora, perhaps open a persistent chat connection if needed. It takes a BackendConfig so that the details are not hard-coded.
Login – as described, perform authentication.
Logout – notify server and cleanup sockets if user logs off.
FetchGameList – query the master server and return a list of games (filling a vector of GameSessionInfo). The game’s UI code (via our hook) will then use this info to display games.
HostGame – register a new game on the master server. We might pass in partial info (like sessionName, maxPlayers) and the function will fill the rest (host IP, generate sessionID). It should also start necessary services like heartbeats and NAT negotiation listeners.
CancelHost – remove the game from listing (called if the host dissolves the lobby without starting a match).
JoinGame – given a GameSessionInfo for a target game, perform the steps to join: contact NATNeg, connect to host, etc. This function will likely trigger the NAT thread and then return true/false for initiating. The actual completion (success or fail to join) might be conveyed via an event or callback rather than the return value (since joining can be asynchronous).
SendInvite – send an invite to a target player for the current hosted game. This may require that we have a way to address that player (either by username or an ID that the backend can use). We might maintain a mapping of friends online from the login step to know where to send the invite.
PumpEvents – this is a utility that processes incoming messages on any open sockets. For example, incoming chat messages (invites, etc.), responses from the master server, or NATNeg responses. The game loop (or a separate thread) can call PumpEvents() frequently. Inside, it will parse any queued network data and then invoke appropriate higher-level handlers (like if an invite message is received, call a function to handle that which in turn triggers game UI). Essentially, this replaces what GameSpy SDK’s internal pump would do.
Callbacks to Game: In addition to these, we’ll have internal callback mechanisms to communicate with the game. For instance, after a successful login in Login(), we should call the game’s original login callback. We can store function pointers or use known addresses to trigger in-game events. Similarly, for asynchronous events like “a new player joined your hosted game” (the game engine might expect a callback from the networking layer), we will call those accordingly. We will map out these callback signatures by studying the GameSpy SDK or using the game’s symbols if available. For example, if the game used peerCallbacks (GameSpy Peer SDK) for things like PEER_CONNECTED, PEER_ROOM_JOIN, etc., we would simulate those events at the right time.The above function prototypes and structures provide a blueprint. In code, the actual implementation might refine parameters (e.g. adding a password parameter to JoinGame if games can be passworded, etc.). But with this interface-oriented design, we isolate the details of Revora vs OpenSpy. For instance, RevoraBackend::Login knows to connect to Revora’s servers, whereas an OpenSpyBackend::Login would connect to OpenSpy’s servers (which might accept any credentials or have different rules). The rest of the game doesn’t need to know which is in use.
Modularity Considerations (Supporting Multiple Backends)
One of the goals is to support multiple backend services with minimal code changes – essentially plug-and-play backends. Our design addresses this in several ways:
Config-Driven Backend Selection: As noted, an external configuration (e.g. an .ini or JSON file) will specify the backend. For example:
ini
Copy
backend = "Revora"
loginServer = "revora.cnc-online.net"
loginPort = 29900
masterServer = "revora.cnc-online.net"
masterPort = 28900
chatServer = "revora.cnc-online.net"
chatPort = 6667
Or, to use OpenSpy:
ini
Copy
backend = "OpenSpy"
loginServer = "openspy.net"    ; or use gamespy.com with hosts redirect
loginPort = 29900
masterServer = "openspy.net"
masterPort = 28900
... 
The code reads this and initializes BackendConfig. This means switching backends is as easy as editing the config (no recompilation). We will ship with Revora’s settings as default. For OpenSpy, the user might change the hostnames or we could provide a preset. (OpenSpy is known to allow GameSpy-era games to work by simply redirecting DNS​
REDDIT.COM
, which suggests our implementation for Revora vs OpenSpy is largely the same protocols, just different server addresses.)
Backend Interface Implementation: By programming against the GameBackend interface, the game’s hooked code doesn’t care which backend is in play. We could even load the backend implementation dynamically as a plugin (for instance, have RevoraBackend.dll and OpenSpyBackend.dll). However, that might be overkill. A simpler approach is to use a single codebase that can handle differences via config. If needed, use conditional logic for any protocol differences. For example, if OpenSpy does not enforce account authentication (some OpenSpy instances allow any login), our Login code can detect backend=="OpenSpy" and skip the password verification step or handle the response differently. These differences are minor since both Revora and OpenSpy aim to emulate GameSpy.
Swappable NAT Server: NAT negotiation might be one area to abstract. Perhaps Revora uses their own NATNeg servers whereas OpenSpy might use a community-run one. We keep the address configurable. If one backend doesn’t provide NAT negotiation, we could default to a community NATNeg server or require manual port forwarding for that backend. By isolating NAT punch-through code, we can adjust or even replace it (for instance, using a standardized STUN/TURN approach in the future) without touching login or listing logic.
Future Backends: The modular design means if tomorrow someone sets up a new server for Zero Hour, we can add it. For example, an enterprising fan might integrate Zero Hour into a new unified gaming service – they could write a new GameBackend subclass for their API and plug it in. As long as our hooks call the interface, everything works.
Testing with Different Backends: We will test with Revora and OpenSpy. OpenSpy, for instance, might not require actual user accounts (it could accept any nickname/password and treat it as logged in). We ensure our code doesn’t falsely assume things like ladder/stats are present. We focus on the common denominator: basic login and game listing. For any advanced features (like stats reporting), we can either implement them for Revora or stub them out for others. The config could have flags like enableStats=true/false.
No Hard-Coded Dependencies: Avoid hard-coding strings like “gpcm.gamespy.com” in the logic. Instead, always use the values from BackendConfig. This way, if Revora ever changes their service domain or if the user wants to run a local server for a LAN party, they can adjust the config (e.g. point all services to a local machine IP) and the game will use that.
Default to Revora’s C&C:Online: Since Revora is the currently maintained community solution​
CNC.FANDOM.COM
, our default settings and testing revolve around it. We know it requires account registration (so our login must handle real authentication and error messages), and it supports the full spectrum (lobbies, NAT, stats). We make sure all features work with Revora. For OpenSpy (as an alternative), we test that at least login and lobby listing works (OpenSpy basically tries to clone GameSpy as well). The user can switch to OpenSpy if Revora is down or if they prefer not to register, by changing the config.
In summary, by separating configuration and logic, and possibly leveraging an interface or plugin system, we achieve a flexible networking layer. The game and our hooks remain the same regardless of backend; only the target servers and slight protocol handling differ. This also helps longevity: if one service shuts down, the community can bring up another by just providing new addresses – our mod can then connect to the new service without needing a re-patch (just a config update).
Testing & Debugging Strategy
Finally, to ensure the new system works reliably, we outline a comprehensive testing plan that can be executed without internet access to gather external info (except when connecting to the actual services for live testing):1. Unit Testing Protocol Logic: Develop small test applications or functions for each protocol segment that can run offline with simulated responses. For example, write a test for the login handshake: simulate the server challenge and verify that our hashing of the password matches known expected output (we can use known test vectors or an offline GameSpy login emulator to verify). Similarly, test parsing of the master server list by feeding a sample master server response (we can record a real GameSpy/Revora response once and use it as test input). These unit tests ensure our parsing and data handling is correct independent of the live server.2. Local Loopback Testing: Without needing internet, we can set up a local dummy server to mimic Revora/OpenSpy. For instance, create a simple TCP server that listens on 29900 and upon receiving a login request, sends back a pre-crafted “success” message. Run the game with our hooks but edit the config to point loginServerHost to 127.0.0.1. This way, we test the full login flow in the game against our dummy server. The game should indicate “logged in” (perhaps showing the online lobby screen). We can similarly host a dummy master server on 28900 that, when asked, sends a fixed game list (perhaps one fake game entry). Running the in-game “refresh”, we verify that the fake game appears in the list. This offline testing approach is very useful to test our code’s integration with the game without relying on Revora’s availability. We essentially simulate the backend. (For NAT punch-through, offline testing is trickier, but we could simulate a NATNeg server locally as well – listening on a UDP port and forwarding packets between two clients running on the same LAN to emulate the handshake.)3. Live Testing (Revora): Once unit and local tests pass, move to testing with the actual Revora C&C:Online service:
Login Tests: Use a known good account to test login. Ensure the game logs in successfully. Test error handling with a wrong password – the game should show the proper error (our hook should catch the failure and relay the error message GameSpy-style to the UI). Also test the account creation process if supported (Revora might not allow creating from game, in which case our replacement should perhaps disable that UI or direct users to the website).
Lobby Listing Tests: After login, verify that the lobby list populates with current games. If possible, coordinate with another tester who hosts a game on Revora. See that the game appears in the list with correct details. Alternatively, host a game yourself on one PC and refresh the list on another PC (or a second instance if possible) to see it. Check that players can see each other’s hosted games.
Hosting/Joining Tests: Test hosting a game: Host on one machine (or instance), and join from another. Go through the entire cycle: the joining player should connect, and the game should launch into the match. Play for a few minutes to ensure stability, then exit gracefully. Also test the reverse (the other machine hosts). If available, test with more than two players (fill up a game lobby of 3-4 if the game supports) to ensure our system handles multiple peer connections and everyone connects (this will particularly stress the NAT negotiation if multiple NATs are involved).
NAT Scenarios: Perform NAT punch-through tests by simulating real-world scenarios. For example, put one PC behind a home router (no port forwarding) and another on a mobile hotspot (which is often symmetric NAT), etc. Try joining games in various combinations (NAT -> NAT, NAT -> public). Verify the success rate. If a connection fails due to NAT, test that our timeout and error message work, and then try with the router port-forwarded to see if that succeeds, confirming that the issue was NAT and not our code.
Invite Tests: Log in two accounts (you might need two game instances or two PCs). Add each other to friends (if the game requires it; if not, just being in the same lobby might suffice). Have one host a game and use the invite friend feature. The other should receive an invite popup. Accept it and ensure it leads into the game successfully. Also test declining an invite (the host should perhaps get a message like “Friend declined” – if the original game had such a feature, we’d emulate it, otherwise just ensure no hang).
Stability and Regression: Play multiple games back-to-back, leaving and rejoining lobbies, to catch any memory leaks or lingering socket issues. Use tools or debug builds to ensure sockets are properly closed on exit from a game, etc. Also test the scenario of “server disconnects”: e.g., simulate the master server going down mid-session – our code should handle timeouts gracefully (maybe alert the player or simply keep last known list). Similarly, if the user is idle in the lobby for a long time, ensure our login connection doesn’t timeout or if it does, we handle reconnecting.
4. OpenSpy Testing: Switch the config to OpenSpy’s backend and repeat critical tests (login, list, join). OpenSpy might allow login with any credentials, so test that (use a random username, it should still “log in” if OpenSpy is open). Ensure the game list appears (OpenSpy might show games hosted by others using OpenSpy for Zero Hour). If none are available, host on one machine with OpenSpy and see if another can see it. Essentially, verify that our abstraction truly works with a different service.5. Offline Mode Fallback (if any): Although not a requirement, it’s worth testing that the game still works in LAN mode or skirmish unaffected by our hooks. Our hooking should ideally detect if the user is trying to play “Network (LAN)” or singleplayer and either bypass or use local connection appropriately. (If our hooks inadvertently interfere with LAN, we might add a check to disable them unless “Online” mode is selected in-game). Test that a LAN game between two PCs still works (if the game has a LAN mode separate from GameSpy, which Generals does). If issues arise (maybe our WinSock init interferes), address them (perhaps separate code paths or a toggle for “use legacy LAN networking”).6. Performance and Load Testing: While Zero Hour isn’t very heavy on networking, we should ensure our system can handle edge cases: e.g., a lobby with dozens of games (does our UI update smoothly?), or rapidly joining/leaving games. If possible, simulate many game entries by forging master server responses to see if any performance bottleneck in parsing or displaying occurs. Also test what happens if the player quickly cancels an action (e.g., tries to join a game then cancels) – our code should properly close any half-open connections and not get confused.Throughout testing, use our logging extensively. Check the logs after each test run for any unexpected errors or warnings. Memory debugging tools can ensure we’re not leaking resources (sockets, memory from buffers, etc.). Each major feature (login, listing, NAT, invite) should be tested in isolation (if possible) and then in a full integration test with real gameplay.By following this testing strategy, we can be confident that the GameSpy replacement is solid. We will have essentially recreated the GameSpy experience with Revora’s backend, all while allowing flexibility to switch to alternatives like OpenSpy. Importantly, all these steps and the information provided have been included here so that a developer can implement and verify the system without needing external references – the relevant protocols and function references have been summarized from known sources​
GAMEFAQS.GAMESPOT.COM
​
FORUM.REALITYMOD.COM
. Once testing is complete and successful, we can release the patch to the community, restoring seamless online play to C&C: Generals – Zero Hour.